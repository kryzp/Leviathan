#version 430

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D o_trail_map;

struct Particle
{
	float x;
	float y;
	float ang;
};

layout(std430, binding = 1) buffer particle_data
{
	Particle particles[250];
};

uint hash(uint state)
{
	state ^= 2747636419u;
	state *= 2654435769u;
	state ^= state >> 16;
	state *= 2654435769u;
	state ^= state >> 16;
	state *= 2654435769u;
	return state;
}

float uint_zero_to_one(uint x)
{
	return float(x) / 4294967295.0;
}

uniform float u_delta_time = 0.0;

const float PI = 3.14159265359;
const float TAU = 6.28318530718;
const float move_speed = 125.0;

void main()
{
	ivec2 size = imageSize(o_trail_map);

	if (gl_GlobalInvocationID.x < 0 || gl_GlobalInvocationID.x >= 250) {
		return;
	}

	Particle particle = particles[gl_GlobalInvocationID.x];
	uint rand = hash(uint(particle.y * size.x) + uint(particle.x) + hash(gl_GlobalInvocationID.x));

	vec2 dir = vec2(cos(particle.ang), sin(particle.ang));
	vec2 newpos = vec2(particle.x, particle.y) + (dir * move_speed * u_delta_time);

	if (newpos.x < 0 || newpos.x >= size.x || newpos.y < 0 || newpos.y >= size.y)
	{
		particles[gl_GlobalInvocationID.x].ang = uint_zero_to_one(rand) * TAU;

		newpos.x = clamp(newpos.x, 0.0, size.x - 0.01);
		newpos.y = clamp(newpos.y, 0.0, size.y - 0.01);
	}

	particles[gl_GlobalInvocationID.x].x = newpos.x;
	particles[gl_GlobalInvocationID.x].y = newpos.y;
	imageStore(o_trail_map, ivec2(newpos.x, newpos.y), vec4(1.0));
}
